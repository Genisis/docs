<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Merge</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Reference" /><link rel="up" href="index-modules.html" title="Index Modules" /><link rel="prev" href="index-modules-slowlog.html" title="Index Slow Log" /><link rel="next" href="index-modules-store.html" title="Store" /><script type="text/javascript" src="http://www.elasticsearch.org/wp-includes/js/jquery/jquery.js?ver=1.8.3"></script><link rel="stylesheet" id="prettify-gc-syntax-highlighter-css" href="http://www.elasticsearch.org/content/plugins/prettify-gc-syntax-highlighter/prettify.css?ver=3.5.2" type="text/css" media="all" /><link rel="stylesheet" id="appStyles-css" href="http://www.elasticsearch.org/content/themes/elasticsearch-org/css/main.css?ver=1376314515" type="text/css" media="all" /><script type="text/javascript" src="http://www.elasticsearch.org/content/themes/elasticsearch-org/js/vendor/modernizr-2.6.1.min.js?ver=1"></script><script type="text/javascript" src="http://www.elasticsearch.org/content/themes/elasticsearch-org/js/vendor/selectivizr-min.js?ver=1"></script><script type="text/javascript" src="http://www.elasticsearch.org/content/themes/elasticsearch-org/js/plugins.min.js?ver=1375472072"></script><link rel="stylesheet" type="text/css" href="styles.css" /></head><body class="single single-guide"><div class="global_wrapper"><div id="index" class="page_content"><div class="container"><section class="full_width guide"><article class="guide_content"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Reference</a></span> &gt; <span class="breadcrumb-link"><a href="index-modules.html">Index Modules</a></span> &gt; <span class="breadcrumb-node">Merge</span></div><div class="navheader"><span class="prev"><a href="index-modules-slowlog.html">
              « 
              Index Slow Log</a>
           
        </span><span class="next">
           
          <a href="index-modules-store.html">Store
               » 
            </a></span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="index-modules-merge"></a>Merge</h2></div></div></div><div class="toc"><dl><dt><span class="chapter"><a href="index-modules-analysis.html">Analysis</a></span></dt><dt><span class="chapter"><a href="index-modules-allocation.html">Index Shard Allocation</a></span></dt><dt><span class="chapter"><a href="index-modules-slowlog.html">Index Slow Log</a></span></dt><dt><span class="chapter"><a href="index-modules-merge.html">Merge</a></span></dt><dt><span class="chapter"><a href="index-modules-store.html">Store</a></span></dt><dt><span class="chapter"><a href="index-modules-mapper.html">Mapper</a></span></dt><dt><span class="chapter"><a href="index-modules-translog.html">Translog</a></span></dt><dt><span class="chapter"><a href="index-modules-cache.html">Cache</a></span></dt><dt><span class="chapter"><a href="index-modules-fielddata.html">Field data</a></span></dt><dt><span class="chapter"><a href="index-modules-codec.html">Codec module</a></span></dt><dt><span class="chapter"><a href="index-modules-similarity.html">Similarity module</a></span></dt></dl></div><p>A shard in elasticsearch is a Lucene index, and a Lucene index is broken
down into segments. Segments are internal storage elements in the index
where the index data is stored, and are immutable up to delete markers.
Segments are, periodically, merged into larger segments to keep the
index size at bay and expunge deletes.</p><p>The more segments one has in the Lucene index mean slower searches and
more memory used, but, low number of segments means more merging that
has to go on.</p><p>Since merges can be expensive to perform, especially on low IO
environments, they can be throttled using store level throttling. Read
the store module documentation on how to set it.</p><h3><a id="_policy"></a>Policy</h3><p>The index merge policy module allows one to control which segments of a
shard index are to be merged. There are several types of policies with
the default set to <code class="literal">tiered</code>.</p><h4><a id="_tiered"></a>tiered</h4><p>Merges segments of approximately equal size, subject to an allowed
number of segments per tier. This is similar to <code class="literal">log_bytes_size</code> merge
policy, except this merge policy is able to merge non-adjacent segment,
and separates how many segments are merged at once from how many
segments are allowed per tier. This merge policy also does not
over-merge (i.e., cascade merges).</p><p>This policy has the following settings:</p><div class="informaltable"><table cellpadding="4px" border="1"><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th align="left" valign="top">Setting </th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">index.merge.policy.expunge_deletes_allowed</code></p></td><td align="left" valign="top"><p>When expungeDeletes is
called, we only merge away a segment if its delete percentage is over
this threshold. Default is <code class="literal">10</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">index.merge.policy.floor_segment</code></p></td><td align="left" valign="top"><p>Segments smaller than this are
"rounded up" to this size, i.e. treated as equal (floor) size for merge
selection. This is to prevent frequent flushing of tiny segments from
allowing a long tail in the index. Default is <code class="literal">2mb</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">index.merge.policy.max_merge_at_once</code></p></td><td align="left" valign="top"><p>Maximum number of segments to
be merged at a time during "normal" merging. Default is <code class="literal">10</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">index.merge.policy.max_merge_at_once_explicit</code></p></td><td align="left" valign="top"><p>Maximum number of
segments to be merged at a time, during optimize or expungeDeletes.
Default is <code class="literal">30</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">index.merge.policy.max_merged_segment</code></p></td><td align="left" valign="top"><p>Maximum sized segment to
produce during normal merging (not explicit optimize). This setting is
approximate: the estimate of the merged segment size is made by summing
sizes of to-be-merged segments (compensating for percent deleted docs).
Default is <code class="literal">5gb</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">index.merge.policy.segments_per_tier</code></p></td><td align="left" valign="top"><p>Sets the allowed number of
segments per tier. Smaller values mean more merging but fewer segments.
Default is <code class="literal">10</code>. Note, this value needs to be &gt;= then the
<code class="literal">max_merge_at_once_</code> otherwise you’ll force too many merges to occur.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">index.reclaim_deletes_weight</code></p></td><td align="left" valign="top"><p>Controls how aggressively merges that
reclaim more deletions are favored. Higher values favor selecting merges
that reclaim deletions. A value of <code class="literal">0.0</code> means deletions don’t impact
merge selection. Defaults to <code class="literal">2.0</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">index.compound_format</code></p></td><td align="left" valign="top"><p>Should the index be stored in compound format
or not. Defaults to <code class="literal">false</code>.</p></td></tr></tbody></table></div><p>For normal merging, this policy first computes a "budget" of how many
segments are allowed by be in the index. If the index is over-budget,
then the policy sorts segments by decreasing size (pro-rating by percent
deletes), and then finds the least-cost merge. Merge cost is measured by
a combination of the "skew" of the merge (size of largest seg divided by
smallest seg), total merge size and pct deletes reclaimed, so that
merges with lower skew, smaller size and those reclaiming more deletes,
are favored.</p><p>If a merge will produce a segment that’s larger than
<code class="literal">max_merged_segment</code> then the policy will merge fewer segments (down to
1 at once, if that one has deletions) to keep the segment size under
budget.</p><p>Note, this can mean that for large shards that holds many gigabytes of
data, the default of <code class="literal">max_merged_segment</code> (<code class="literal">5gb</code>) can cause for many
segments to be in an index, and causing searches to be slower. Use the
indices segments API to see the segments that an index have, and
possibly either increase the <code class="literal">max_merged_segment</code> or issue an optimize
call for the index (try and aim to issue it on a low traffic time).</p><h4><a id="_log_byte_size"></a>log_byte_size</h4><p>A merge policy that merges segments into levels of exponentially
increasing <span class="strong"><strong>byte size</strong></span>, where each level has fewer segments than the
value of the merge factor. Whenever extra segments (beyond the merge
factor upper bound) are encountered, all segments within the level are
merged.</p><p>This policy has the following settings:</p><div class="informaltable"><table cellpadding="4px" border="1"><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th align="left" valign="top">Setting </th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>index.merge.policy.merge_factor</p></td><td align="left" valign="top"><p>Determines how often segment indices
are merged by index operation. With smaller values, less RAM is used
while indexing, and searches on unoptimized indices are faster, but
indexing speed is slower. With larger values, more RAM is used during
indexing, and while searches on unoptimized indices are slower, indexing
is faster. Thus larger values (greater than 10) are best for batch index
creation, and smaller values (lower than 10) for indices that are
interactively maintained. Defaults to <code class="literal">10</code>.</p></td></tr><tr><td align="left" valign="top"><p>index.merge.policy.min_merge_size</p></td><td align="left" valign="top"><p>A size setting type which sets the
minimum size for the lowest level segments. Any segments below this size
are considered to be on the same level (even if they vary drastically in
size) and will be merged whenever there are mergeFactor of them. This
effectively truncates the "long tail" of small segments that would
otherwise be created into a single level. If you set this too large, it
could greatly increase the merging cost during indexing (if you flush
many small segments). Defaults to <code class="literal">1.6mb</code></p></td></tr><tr><td align="left" valign="top"><p>index.merge.policy.max_merge_size</p></td><td align="left" valign="top"><p>A size setting type which sets the
largest segment (measured by total byte size of the segment’s files)
that may be merged with other segments. Defaults to unbounded.</p></td></tr><tr><td align="left" valign="top"><p>index.merge.policy.max_merge_docs</p></td><td align="left" valign="top"><p>Determines the largest segment
(measured by document count) that may be merged with other segments.
Defaults to unbounded.</p></td></tr></tbody></table></div><h4><a id="_log_doc"></a>log_doc</h4><p>A merge policy that tries to merge segments into levels of exponentially
increasing <span class="strong"><strong>document count</strong></span>, where each level has fewer segments than
the value of the merge factor. Whenever extra segments (beyond the merge
factor upper bound) are encountered, all segments within the level are
merged.</p><div class="informaltable"><table cellpadding="4px" border="1"><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th align="left" valign="top">Setting </th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>index.merge.policy.merge_factor</p></td><td align="left" valign="top"><p>Determines how often segment indices
are merged by index operation. With smaller values, less RAM is used
while indexing, and searches on unoptimized indices are faster, but
indexing speed is slower. With larger values, more RAM is used during
indexing, and while searches on unoptimized indices are slower, indexing
is faster. Thus larger values (greater than 10) are best for batch index
creation, and smaller values (lower than 10) for indices that are
interactively maintained. Defaults to <code class="literal">10</code>.</p></td></tr><tr><td align="left" valign="top"><p>index.merge.policy.min_merge_docs</p></td><td align="left" valign="top"><p>Sets the minimum size for the lowest
level segments. Any segments below this size are considered to be on the
same level (even if they vary drastically in size) and will be merged
whenever there are mergeFactor of them. This effectively truncates the
"long tail" of small segments that would otherwise be created into a
single level. If you set this too large, it could greatly increase the
merging cost during indexing (if you flush many small segments).
Defaults to <code class="literal">1000</code>.</p></td></tr><tr><td align="left" valign="top"><p>index.merge.policy.max_merge_docs</p></td><td align="left" valign="top"><p>Determines the largest segment
(measured by document count) that may be merged with other segments.
Defaults to unbounded.</p></td></tr></tbody></table></div><h3><a id="_scheduling"></a>Scheduling</h3><p>The merge schedule controls the execution of merge operations once they
are needed (according to the merge policy). The following types are
supported, with the default being the <code class="literal">ConcurrentMergeScheduler</code>.</p><h4><a id="_concurrentmergescheduler"></a>ConcurrentMergeScheduler</h4><p>A merge scheduler that runs merges using a separated thread, until the
maximum number of threads at which when a merge is needed, the thread(s)
that are updating the index will pause until one or more merges
completes.</p><p>The scheduler supports the following settings:</p><div class="informaltable"><table cellpadding="4px" border="1"><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th align="left" valign="top">Setting </th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>index.merge.scheduler.max_thread_count</p></td><td align="left" valign="top"><p>The maximum number of threads
to perform the merge operation. Defaults to
<code class="literal">Math.max(1, Math.min(3, Runtime.getRuntime().availableProcessors() / 2))</code>.</p></td></tr></tbody></table></div><h4><a id="_serialmergescheduler"></a>SerialMergeScheduler</h4><p>A merge scheduler that simply does each merge sequentially using the
calling thread (blocking the operations that triggered the merge, the
index operation).</p></div><div class="navfooter"><span class="prev"><a href="index-modules-slowlog.html">
              « 
              Index Slow Log</a>
           
        </span><span class="next">
           
          <a href="index-modules-store.html">Store
               » 
            </a></span></div></article></section></div></div></div><script type="text/javascript" src="http://www.elasticsearch.org/content/plugins/prettify-gc-syntax-highlighter/prettify.js?ver=3.5.2"></script><script type="text/javascript" src="http://www.elasticsearch.org/content/plugins/prettify-gc-syntax-highlighter/launch.js?ver=3.5.2"></script></body></html>
