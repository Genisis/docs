<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Cluster</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Reference" /><link rel="up" href="modules.html" title="Modules" /><link rel="prev" href="modules.html" title="Modules" /><link rel="next" href="modules-discovery.html" title="Discovery" /><script type="text/javascript" src="http://www.elasticsearch.org/wp-includes/js/jquery/jquery.js?ver=1.8.3"></script><link rel="stylesheet" id="prettify-gc-syntax-highlighter-css" href="http://www.elasticsearch.org/content/plugins/prettify-gc-syntax-highlighter/prettify.css?ver=3.5.2" type="text/css" media="all" /><link rel="stylesheet" id="appStyles-css" href="http://www.elasticsearch.org/content/themes/elasticsearch-org/css/main.css?ver=1376314515" type="text/css" media="all" /><script type="text/javascript" src="http://www.elasticsearch.org/content/themes/elasticsearch-org/js/vendor/modernizr-2.6.1.min.js?ver=1"></script><script type="text/javascript" src="http://www.elasticsearch.org/content/themes/elasticsearch-org/js/vendor/selectivizr-min.js?ver=1"></script><script type="text/javascript" src="http://www.elasticsearch.org/content/themes/elasticsearch-org/js/plugins.min.js?ver=1375472072"></script><link rel="stylesheet" type="text/css" href="styles.css" /></head><body class="single single-guide"><div class="global_wrapper"><div id="index" class="page_content"><div class="container"><section class="full_width guide"><article class="guide_content"><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Reference</a></span> &gt; <span class="breadcrumb-link"><a href="modules.html">Modules</a></span> &gt; <span class="breadcrumb-node">Cluster</span></div><div class="navheader"><span class="prev"><a href="modules.html">
              « 
              Modules</a>
           
        </span><span class="next">
           
          <a href="modules-discovery.html">Discovery
               » 
            </a></span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="modules-cluster"></a>Cluster</h2></div></div></div><div class="toc"><dl><dt><span class="chapter"><a href="modules-cluster.html">Cluster</a></span></dt><dt><span class="chapter"><a href="modules-discovery.html">Discovery</a></span></dt><dt><span class="chapter"><a href="modules-gateway.html">Gateway</a></span></dt><dt><span class="chapter"><a href="modules-http.html">HTTP</a></span></dt><dt><span class="chapter"><a href="modules-indices.html">Indices</a></span></dt><dt><span class="chapter"><a href="modules-memcached.html">memcached</a></span></dt><dt><span class="chapter"><a href="modules-network.html">Network Settings</a></span></dt><dt><span class="chapter"><a href="modules-node.html">Node</a></span></dt><dt><span class="chapter"><a href="modules-plugins.html">Plugins</a></span></dt><dt><span class="chapter"><a href="modules-scripting.html">Scripting</a></span></dt><dt><span class="chapter"><a href="modules-threadpool.html">Thread Pool</a></span></dt><dt><span class="chapter"><a href="modules-thrift.html">Thrift</a></span></dt><dt><span class="chapter"><a href="modules-transport.html">Transport</a></span></dt></dl></div><h3><a id="_shards_allocation"></a>Shards Allocation</h3><p>Shards allocation is the process of allocating shards to nodes. This can
happen during initial recovery, replica allocation, rebalancing, or
handling nodes being added or removed.</p><p>The following settings may be used:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<code class="literal">cluster.routing.allocation.allow_rebalance</code>
</span></dt><dd>
        Allow to control when rebalancing will happen based on the total
        state of all the indices shards in the cluster. <code class="literal">always</code>,
        <code class="literal">indices_primaries_active</code>, and <code class="literal">indices_all_active</code> are allowed,
        defaulting to <code class="literal">indices_all_active</code> to reduce chatter during
        initial recovery.
</dd><dt><span class="term">
<code class="literal">cluster.routing.allocation.cluster_concurrent_rebalance</code>
</span></dt><dd>
      Allow to control how many concurrent rebalancing of shards are
      allowed cluster wide, and default it to <code class="literal">2</code>.
</dd><dt><span class="term">
<code class="literal">cluster.routing.allocation.node_initial_primaries_recoveries</code>
</span></dt><dd>
       Allow to control specifically the number of initial recoveries
       of primaries that are allowed per node. Since most times local
       gateway is used, those should be fast and we can handle more of
       those per node without creating load.
</dd><dt><span class="term">
<code class="literal">cluster.routing.allocation.node_concurrent_recoveries</code>
</span></dt><dd>
     How many concurrent recoveries are allowed to happen on a node.
     Defaults to <code class="literal">2</code>.
</dd><dt><span class="term">
<code class="literal">cluster.routing.allocation.disable_new_allocation</code>
</span></dt><dd>
       Allows to disable new primary allocations. Note, this will prevent
       allocations for newly created indices. This setting really make
       sense when dynamically updating it using the cluster update
       settings API.
</dd><dt><span class="term">
<code class="literal">cluster.routing.allocation.disable_allocation</code>
</span></dt><dd>
        Allows to disable either primary or replica allocation (does not
        apply to newly created primaries, see <code class="literal">disable_new_allocation</code>
        above). Note, a replica will still be promoted to primary if
        one does not exist. This setting really make sense when
        dynamically updating it using the cluster update settings API.
</dd><dt><span class="term">
<code class="literal">cluster.routing.allocation.disable_replica_allocation</code>
</span></dt><dd>
      Allows to disable only replica allocation. Similar to the previous
      setting, mainly make sense when using it dynamically using the
      cluster update settings API.
</dd><dt><span class="term">
<code class="literal">indices.recovery.concurrent_streams</code>
</span></dt><dd>
       The number of streams to open (on a <span class="strong"><strong>node</strong></span> level) to recover a
       shard from a peer shard. Defaults to <code class="literal">3</code>.
</dd></dl></div><h3><a id="_shard_allocation_awareness"></a>Shard Allocation Awareness</h3><p>Cluster allocation awareness allows to configure shard and replicas
allocation across generic attributes associated the nodes. Lets explain
it through an example:</p><p>Assume we have several racks. When we start a node, we can configure an
attribute called <code class="literal">rack_id</code> (any attribute name works), for example, here
is a sample config:</p><pre class="screen">node.rack_id: rack_one</pre><p>The above sets an attribute called <code class="literal">rack_id</code> for the relevant node with
a value of <code class="literal">rack_one</code>. Now, we need to configure the <code class="literal">rack_id</code> attribute
as one of the awareness allocation attributes (set it on <span class="strong"><strong>all</strong></span> (master
eligible) nodes config):</p><pre class="screen">cluster.routing.allocation.awareness.attributes: rack_id</pre><p>The above will mean that the <code class="literal">rack_id</code> attribute will be used to do
awareness based allocation of shard and its replicas. For example, lets
say we start 2 nodes with <code class="literal">node.rack_id</code> set to <code class="literal">rack_one</code>, and deploy a
single index with 5 shards and 1 replica. The index will be fully
deployed on the current nodes (5 shards and 1 replica each, total of 10
shards).</p><p>Now, if we start two more nodes, with <code class="literal">node.rack_id</code> set to <code class="literal">rack_two</code>,
shards will relocate to even the number of shards across the nodes, but,
a shard and its replica will not be allocated in the same <code class="literal">rack_id</code>
value.</p><p>The awareness attributes can hold several values, for example:</p><pre class="screen">cluster.routing.allocation.awareness.attributes: rack_id,zone</pre><p><span class="strong"><strong>NOTE</strong></span>: When using awareness attributes, shards will not be allocated to
nodes that don’t have values set for those attributes.</p><h3><a id="_forced_awareness"></a>Forced Awareness</h3><p>Sometimes, we know in advance the number of values an awareness
attribute can have, and more over, we would like never to have more
replicas then needed allocated on a specific group of nodes with the
same awareness attribute value. For that, we can force awareness on
specific attributes.</p><p>For example, lets say we have an awareness attribute called <code class="literal">zone</code>, and
we know we are going to have two zones, <code class="literal">zone1</code> and <code class="literal">zone2</code>. Here is how
we can force awareness one a node:</p><pre class="programlisting prettyprint lang-js">cluster.routing.allocation.awareness.force.zone.values: zone1,zone2
cluster.routing.allocation.awareness.attributes: zone</pre><p>Now, lets say we start 2 nodes with <code class="literal">node.zone</code> set to <code class="literal">zone1</code> and
create an index with 5 shards and 1 replica. The index will be created,
but only 5 shards will be allocated (with no replicas). Only when we
start more shards with <code class="literal">node.zone</code> set to <code class="literal">zone2</code> will the replicas be
allocated.</p><h4><a id="_automatic_preference_when_searching_geting"></a>Automatic Preference When Searching / GETing</h4><p>When executing a search, or doing a get, the node receiving the request
will prefer to execute the request on shards that exists on nodes that
have the same attribute values as the executing node.</p><h4><a id="_realtime_settings_update"></a>Realtime Settings Update</h4><p>The settings can be updated using the <a class="link" href="cluster-update-settings.html" title="Cluster Update Settings">cluster update settings API</a> on a live cluster.</p><h3><a id="_shard_allocation_filtering"></a>Shard Allocation Filtering</h3><p>Allow to control allocation if indices on nodes based on include/exclude
filters. The filters can be set both on the index level and on the
cluster level. Lets start with an example of setting it on the cluster
level:</p><p>Lets say we have 4 nodes, each has specific attribute called <code class="literal">tag</code>
associated with it (the name of the attribute can be any name). Each
node has a specific value associated with <code class="literal">tag</code>. Node 1 has a setting
<code class="literal">node.tag: value1</code>, Node 2 a setting of <code class="literal">node.tag: value2</code>, and so on.</p><p>We can create an index that will only deploy on nodes that have <code class="literal">tag</code>
set to <code class="literal">value1</code> and <code class="literal">value2</code> by setting
<code class="literal">index.routing.allocation.include.tag</code> to <code class="literal">value1,value2</code>. For example:</p><pre class="programlisting prettyprint lang-js">curl -XPUT localhost:9200/test/_settings -d '{
      "index.routing.allocation.include.tag" : "value1,value2"
}'</pre><p>On the other hand, we can create an index that will be deployed on all
nodes except for nodes with a <code class="literal">tag</code> of value <code class="literal">value3</code> by setting
<code class="literal">index.routing.allocation.exclude.tag</code> to <code class="literal">value3</code>. For example:</p><pre class="programlisting prettyprint lang-js">curl -XPUT localhost:9200/test/_settings -d '{
      "index.routing.allocation.exclude.tag" : "value3"
}'</pre><p><code class="literal">index.routing.allocation.require.*</code> can be used to
specify a number of rules, all of which MUST match in order for a shard
to be  allocated to a node. This is in contrast to <code class="literal">include</code> which will
include a node if ANY rule matches.</p><p>The <code class="literal">include</code>, <code class="literal">exclude</code> and <code class="literal">require</code> values can have generic simple
matching wildcards, for example, <code class="literal">value1*</code>. A special attribute name
called <code class="literal">_ip</code> can be used to match on node ip values. In addition <code class="literal">_host</code>
attribute can be used to match on either the node’s hostname or its ip
address.</p><p>Obviously a node can have several attributes associated with it, and
both the attribute name and value are controlled in the setting. For
example, here is a sample of several node configurations:</p><pre class="programlisting prettyprint lang-js">node.group1: group1_value1
node.group2: group2_value4</pre><p>In the same manner, <code class="literal">include</code>, <code class="literal">exclude</code> and <code class="literal">require</code> can work against
several attributes, for example:</p><pre class="programlisting prettyprint lang-js">curl -XPUT localhost:9200/test/_settings -d '{
    "index.routing.allocation.include.group1" : "xxx"
    "index.routing.allocation.include.group2" : "yyy",
    "index.routing.allocation.exclude.group3" : "zzz",
    "index.routing.allocation.require.group4" : "aaa"
}'</pre><p>The provided settings can also be updated in real time using the update
settings API, allowing to "move" indices (shards) around in realtime.</p><p>Cluster wide filtering can also be defined, and be updated in real time
using the cluster update settings API. This setting can come in handy
for things like decommissioning nodes (even if the replica count is set
to 0). Here is a sample of how to decommission a node based on <code class="literal">_ip</code>
address:</p><pre class="programlisting prettyprint lang-js">curl -XPUT localhost:9200/_cluster/settings -d '{
    "transient" : {
        "cluster.routing.allocation.exclude._ip" : "10.0.0.1"
    }
}'</pre></div><div class="navfooter"><span class="prev"><a href="modules.html">
              « 
              Modules</a>
           
        </span><span class="next">
           
          <a href="modules-discovery.html">Discovery
               » 
            </a></span></div></article></section></div></div></div><script type="text/javascript" src="http://www.elasticsearch.org/content/plugins/prettify-gc-syntax-highlighter/prettify.js?ver=3.5.2"></script><script type="text/javascript" src="http://www.elasticsearch.org/content/plugins/prettify-gc-syntax-highlighter/launch.js?ver=3.5.2"></script></body></html>
